<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>station</title>
</head>

<script src="pixi/pixi.min.js"></script>
<script src="pixi/dust.js"></script>
<script src="pixi/spriteUtilities.js"></script>
<script src="pixi/bump.js"></script>
<script src="pixi/jquery-3.3.1.min.js"></script>

<body>

    <script type="text/javascript">
        let type = "WebGL"
        if (!PIXI.utils.isWebGLSupported()) {
            type = "canvas"
        }
        PIXI.utils.sayHello(type)

        let Application = PIXI.Application,
            Container = PIXI.Container,
            loader = PIXI.loader,
            resources = PIXI.loader.resources,
            TextureCache = PIXI.utils.TextureCache,
            Sprite = PIXI.Sprite,
            Rectangle = PIXI.Rectangle,
            Graphics = PIXI.Graphics

        let u = new SpriteUtilities(PIXI);
        let d = new Dust(PIXI);
        //碰撞检测初始化
        let b = new Bump(PIXI);

        //初始背景绘制
        let backImage;
        //模拟变量
        let modifyCount;
        //create a Pixi App
        let app = new Application({
            width: 1920,
            height: 850,
            antialiasing: true,
            transparent: false,
            resolution: 1
        });

        let hexColor = u.color("white");
        app.renderer.backgroundColor = hexColor; //蓝色 16进制码
        document.body.appendChild(app.view);

        //loader an image and run the 'setup' function when it's done
        //添加json文件,并加载'setup'函数
        loader
            .add([
                "./realImages/factory.json",
            ])
            .on("progress", loadProgressHandler)
            .load(setup);

        //This setup function that will run when the image has loaded
        function setup() {
            //管道加载
            backImage = TextureCache['空压机内部结构.svg'];
            //初始化为0,便于调节
            let relativeleft = 0;
            //初始化为0,便于调节
            let relativewidth = 0;
            //第一层级
            backImage = imageFillAndinteractive(backImage, 238 + relativeleft, 56 + relativewidth, 1, false);

            tempTextPure = backImage;
            //上下左右箭头加载
            let left = keyboard(37),
                up = keyboard(38),
                right = keyboard(39),
                down = keyboard(40);

            //Left arrow key `release` method  左箭头释放
            left.release = () => {

            }
            //Right arrow key 'press' method
            let change = 5;

            //Left arrow key `press` method          
            left.press = () => {
                //左键调节
                tempTextPure.x -= change;
                console.log(tempTextPure.x + ": " + tempTextPure.y);
            };
            right.press = () => {
                //右键调节
                tempTextPure.x += change;
                console.log(tempTextPure.x + ": " + tempTextPure.y);
            }
            //Up arrow key 'press' method
            up.press = () => {
                //上键调节
                tempTextPure.y -= change;
                console.log(tempTextPure.x + ": " + tempTextPure.y);
            }
            //Down arrow key 'press' method
            down.press = (event) => {
                //下键调节
                tempTextPure.y += change;
                console.log(tempTextPure.x + ": " + tempTextPure.y);
            }


            //添加鼠标点击事件到元素中
            function clickEventAdd(sprite) {
                sprite.interactive = true;
                sprite.buttonMode = true;
            }

            app.ticker.add(delta => gameLoop(delta));
        }
        setInterval(modXY, 6000);

        function modXY() {
            var url = "";
            $.ajax({
                url: "http://localhost:35544/Home/TestWeb",
                type: "GET",
                success: function (data) {
                    modifyCount = data;
                },
                error: function (res) {
                    // alert(res);
                }
            });
        }

        //加载程序进程
        function loadProgressHandler(loader, resource) {
            console.log("loading " + resource.url)
            console.log("progress " + loader.progress + " %");
        }

        //每秒60帧运行函数
        function gameLoop(delta) {}

        //鼠标拖放事件函数
        function loadMouseEvent(sprite) {
            // create our little sprite friend..
            // var sprite = new PIXI.Sprite(texture);
            // enable the sprite to be interactive... this will allow it to respond to mouse and touch events
            sprite.interactive = true;

            // this button mode will mean the hand cursor appears when you roll over the sprite with your mouse
            sprite.buttonMode = true;

            // setup events for mouse + touch using
            // the pointer events
            // sprite
            //     .on('pointerdown', onDragStart)
            //     .on('pointerup', onDragEnd)
            //     .on('pointerupoutside', onDragEnd)
            //     .on('pointermove', onDragMove);

            // For mouse-only events
            sprite
                .on('mousedown', onDragStart)
                .on('mouseup', onDragEnd)
                .on('mouseupoutside', onDragEnd)
                .on('mousemove', onDragMove);

            // For touch-only events
            // sprite
            //     .on('touchstart', onDragStart)
            //     .on('touchend', onDragEnd)
            //     .on('touchendoutside', onDragEnd)
            //     .on('touchmove', onDragMove);

        }


        //鼠标拖拽开始
        function onDragStart(event) {
            // store a reference to the data
            // the reason for this is because of multitouch
            // we want to track the movement of this particular touch
            this.data = event.data;
            this.alpha = 0.5;
            this.dragging = true;
        }
        //鼠标拖拽结束
        function onDragEnd(event) {
            // this.alpha = 1;
            // this.dragging = false;
            // // set the interaction data to null
            // this.data = null;
            this.alpha = 1;
            this.dragging = false;
            // set the interaction data to null
            var newPosition = this.data.getLocalPosition(this.parent);
            this.x = newPosition.x;
            this.y = newPosition.y;
            console.log("this X:" + this.x + " this Y:" + this.y);
        }
        //鼠标拖拽过程
        function onDragMove() {
            // if (this.dragging) {
            //     var newPosition = this.data.getLocalPosition(this.parent);
            //      this.x = newPosition.x;
            //      this.y = newPosition.y;
            //      console.log("this X:" + this.x + "  this Y:" + this.y);
            // }
        }

        function imageFill(imageFill, x, y, scale, debug, func) {
            imageFill = new Sprite(imageFill);
            if (debug) {
                loadMouseEvent(imageFill);
            }
            //缩放大小 1为默认状态
            imageFill.scale.set(scale);
            imageFill.position.set(x, y);
            app.stage.addChild(imageFill);
            return imageFill;
        }

        function imageFillAndinteractive(image, x, y, scale, debug, func) {
            image = imageFill(image, x, y, scale, debug, func);
            // enable the image to be interactive... this will allow it to respond to mouse and touch events
            image.interactive = true;
            // this button mode will mean the hand cursor appears when you roll over the image with your mouse
            image.buttonMode = true;
            return image;
        }



        //矩形填充
        function rectangleFill(rectangleFill, x, y, width, height, debug, fillColor, func) {
            //用气区域流量
            rectangleFill = new Graphics();
            if (fillColor == undefined) {
                fillColor = "#e6e6e6";
            }
            rectangleFill.beginFill(u.color(fillColor));
            if (debug) {
                loadMouseEvent(rectangleFill);
            }
            //   rectangleFill.position.set(x, y);
            rectangleFill.drawRect(x, y, width, height);
            rectangleFill.endFill();
            app.stage.addChild(rectangleFill);
            return rectangleFill;
        }

        //用户区域流量文字加载
        function textFill(textFill, x, y, message, debug, func) {
            //用气区域 用户压力文字加载
            textFill = new PIXI.Text(message);
            //初始文字位置 set(x,y) x:left y:top
            //textFill.x = 0;
            //textFill.y = 0;
            if (debug) {
                loadMouseEvent(textFill);
            }
            textFill.position.set(x, y);
            textFill.style = {
                fill: "black",
                font: "15px"
            };
            app.stage.addChild(textFill);
            return textFill;
        }



        //键盘事件函数
        function keyboard(keyCode) {
            let key = {};
            key.code = keyCode;
            key.isDown = false;
            key.isUp = true;
            key.press = undefined;
            key.release = undefined;
            //The `downHandler`
            key.downHandler = event => {
                if (event.keyCode === key.code) {
                    if (key.isUp && key.press) key.press();
                    key.isDown = true;
                    key.isUp = false;
                }
                event.preventDefault();
            };

            //The `upHandler`
            key.upHandler = event => {
                if (event.keyCode === key.code) {
                    if (key.isDown && key.release) key.release();
                    key.isDown = false;
                    key.isUp = true;
                }
                event.preventDefault();
            };

            //Attach event listeners
            window.addEventListener(
                "keydown", key.downHandler.bind(key), false
            );
            window.addEventListener(
                "keyup", key.upHandler.bind(key), false
            );
            return key;
        }
    </script>
</body>

</html>